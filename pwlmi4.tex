\documentclass[aspectratio=169,dvipsnames]{beamer}
\usepackage[utf8]{inputenc}
\usefonttheme{serif}
\usetheme{boxes}
\setbeamertemplate{frametitle}[default][center]
\setbeamersize{text margin right=20mm, text margin left=20mm} 
\addtobeamertemplate{frametitle}{\vskip1cm}{}
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{itemize item}[circle]

%% absolute positioning
\usepackage[absolute,overlay]{textpos}
\usepackage{mathrsfs} % https://www.ctan.org/pkg/mathrsfs

\usepackage{fancyvrb}
\usepackage{xspace}
\usepackage{changepage}
\usepackage[version=0.96]{pgf}
\usepackage{tikz}

\newcommand<>{\highlight}[1]{{\alt#2{\colorbox#2{yellow}{#1}}{#1}}}


\usetikzlibrary{fit,shapes.geometric,calc,decorations.pathmorphing}
%Information to be included in the title page:
\title{\bf\LARGE Papers We Love \textcolor{gray}{Milano} \#4}
\subtitle{Partial Computation of Programs\\[5pt] (Futamura 1984)}
\author{Edoardo Vacchi}
% \institute{Overleaf}
\date{19th February 2020}

\renewcommand{\P}{\ensuremath{\mathcal{P}}\xspace}
\newcommand{\C}{\ensuremath{\mathcal{C}}\xspace}
\newcommand{\I}{\ensuremath{\mathcal{I}}\xspace}
\newcommand{\D}{\ensuremath{\mathcal{D}}\xspace}
\newcommand{\R}{\ensuremath{\mathcal{R}}\xspace}
 
\begin{document}
 
\frame{\titlepage}

\begin{frame}
    \tikz[overlay]
    \node at (6,-.5) {\includegraphics[width=33cm]{imgs/futamura.png}};
\end{frame}

\begin{frame}
    \centering
    \tikz 
    \node at (current page.center) {\includegraphics[width=.8\textwidth]{imgs/abstract.png}};
\end{frame}

\begin{frame}
    \centering
    \tikz 
    \node at (current page.center) {\includegraphics[width=.8\textwidth]{imgs/abstract-hl.png}};
\end{frame}

\begin{frame}
    \centering
    \tikz 
    \node at (current page.center) {\includegraphics[width=.9\textwidth]{imgs/conclusions.png}};
\end{frame}

\begin{frame}    
    \centering
    \tikz 
    \node at (current page.center) {\includegraphics[width=.9\textwidth]{imgs/conclusions-hl.png}};
\end{frame}



\begin{frame}[c]
    \centering \Large \bf \color{Blue} Programs and Programming Languages 
    \end{frame}

\begin{frame}
    \tikz[overlay]
    \node[text width=.5\textwidth] at (1.3,-.5) {
    {\hspace{10pt}\Large \color{Blue} {Programs} }

    \begin{itemize}
        \item We call a \textit{program} a \textit{sequence of instructions}
         that can be \textit{executed} by a \textit{machine}.
         \item The \textit{machine} may be a \textit{virtual} machine or a \textit{physical} machine
        \item In the following, when we say that a \textit{program} is \textit{evaluated},
        we assume that there exists some \textit{machine} that is able to execute these instructions.
    \end{itemize}
    };
    \tikz[overlay]
    \node[text width=.5\textwidth] at (7.5,-.5) {
        \includegraphics[width=10cm]{imgs/hackerman.jpg}
    };
\end{frame}

\begin{frame}{Program Evaluation}

    \begin{itemize}
        \item Consider a program \P, with input data \D;
        \item when we \textit{evaluate} \P over \D it produces
        some output result \R.
    \end{itemize}



    \begin{center}
    
        \begin{tikzpicture}
            \tikzstyle{every path}=[draw, ->]
            \tikzstyle{circ}=[draw, circle]
            \tikzstyle{box}=[draw, rectangle, text width=1cm, text height=.5cm, text centered, text depth=.3cm]
                \node [circ] (d) at (2,2) {\D};    
                \node [circ] (r) at (8,2) {\R};    
                \node [box] (p) at (5,2) {\P}; 
                \path (d) -- (p);    
                \path (p) -- (r);    
        \end{tikzpicture}
        
    \end{center}


    
\end{frame}

\begin{frame}{Interpreters}

    \begin{itemize}
    \item An \textit{interpreter} $\mathcal{I}$ is a \textit{program} 
    \item it \textit{evaluates} some other given program $\mathcal{P}$
    over some given data $\mathcal{D}$, and it produces the output
    result \R.
    \end{itemize}


\begin{center}

    \begin{tikzpicture}
        \tikzstyle{every path}=[draw, ->]
        \tikzstyle{circ}=[draw, circle]
        \tikzstyle{box}=[draw, rectangle, text width=1cm, text height=.5cm, text centered, text depth=.3cm]
            \node [circ] (p) at (2,3) {\P};    
            \node [circ] (d) at (2,1) {\D};    
            \node [circ] (r) at (8,2) {\R};    
            \node [box] (i) at (5,2) {\I}; 
            \path (p) -- (i);    
            \path (d) -- (i);    
            \path (i) -- (r);    
    \end{tikzpicture}
    
\end{center}


\end{frame}



\begin{frame}{Compilers}

    \begin{itemize}

        \item 
            Let be \P a program that evaluates to \R when given \D;
        \item  
            A \textit{compiler} $\mathcal{C}$ translates a \textbf{source program}
            $\mathcal{P}$ into an \textbf{object program} $\P'$ that
            evaluated over an input \D still produces \R
        
    
    
    \end{itemize}




    \begin{center}
    
        \begin{tikzpicture}
            \tikzstyle{every path}=[draw, ->]
            \tikzstyle{circ}=[draw, circle]
            \tikzstyle{box}=[draw, rectangle, text width=1cm, text height=.5cm, text centered, text depth=.3cm]
                \node [circ] (p)   at (2,2) {\P};    
                \node [box]  (c)   at (5,2) {\C}; 
                \node [circ] (cp)  at (8,2) {$\P'$};    
                \node [box]  (cp2) at (5,0) {$\P'$};    
                \node [circ] (d)   at (2,0) {\D};    
                \node [circ] (r)   at (8,0) {\R};    
                \path (p) -- (c);    
                \path (c) -- (cp);    
                \path (d) -- (cp2);    
                \path (cp2) -- (r);    
        \end{tikzpicture}
        
    \end{center}

\end{frame}

\begin{frame}
    \begin{itemize}
    \item \textit{With a bit of abuse of notation}, let us denote the result 
    of a program \P evaluated over an input \D with \[
        \P(\D)
        \] 
    \pause
    \item Now, if we indicate $\P'$ with $\C(\P)$ we can write the following:
    \end{itemize}
    \begin{eqnarray*}        
        \P(\D) &=& \R\\
        \C(\P) &=& \P'\\
        \P'(\D) &=& \R\\
        \C(\P)(\D) &=& \R\\
        \I(\P, \D) &=& \R\\
        \C(\P)(\D) &=& \I(\P, \D) \\
    \end{eqnarray*}
    
\end{frame}




\begin{frame}[c]
    \centering \Large \bf \color{Blue} Partial Evaluation 
\end{frame}

\begin{frame}{Partial Evaluation (intuition)}
\begin{center}Let us have a computation $f$ of two parameters $k$, $u$\end{center}
    \[
        f(k,u)
    \]
    \begin{itemize}
    \item Now suppose that $f$ is often called with $k=5$; 
    
    \item we may define the program $f_5(u)$ by substituting $5$ for $k$ in $f$ 
    and doing all possible computation based upon value $5$.

    \item  Partial evaluation is the process of rewriting $f(5,u)$ into $f_5(u)$
    \end{itemize}
\end{frame}
 


\begin{frame}

    \includegraphics[width=\textwidth]{imgs/fig1.png}

\end{frame}
 


\begin{frame}

    \includegraphics[width=\textwidth]{imgs/fig2.png}

\end{frame}




\begin{frame}[fragile]
\begin{adjustwidth}{-3em}{-4em}
\tikz[remember picture, overlay] 
\node at (17,-4) {\includegraphics[height=10cm]{imgs/unix.jpg}};

{ \Large\color{Blue}{This is Currying! I Know This!}}

\begin{minipage}{0.50\textwidth}
\vspace{15pt}
\begin{itemize}
    \item Not exactly!
        In \emph{functional programming} \emph{currying} or 
        \emph{partial application} is $f_5(u) := f(5,u)$

\begin{verbatim}
let f = 
 (k, u) =>  
  (k, u) =>  
 (k, u) =>  
  k * (k * (k+1) + u + 1) + u * u;
let f2 = (u) => f(2, u);
\end{verbatim}
\item In a functional programming language this usually \emph{does not change}
            the program that implements $f$
\end{itemize}


\end{minipage}
\end{adjustwidth}
\end{frame}

\begin{frame}[fragile]{Projection}
    
\begin{verbatim}
    let f = (k, u) => k * (k * (k+1) + u + 1) + u * u;
    let f2 = (u) => 2 * (7 + u) + u * u;
\end{verbatim}

% because $f(2,u) = f_2(u)$ for any value of $u$, 

\centering
the following equation holds for $f_k$ and $f$


    \begin{equation}
        f_k(u)=f(k,u)
    \end{equation}

\centering
we call this \textit{a projection of $f$ at $k$}

\end{frame}


\begin{frame}[fragile]
    \begin{verbatim}
        function pow(n, k) {
            if (k <= 0) {
                return 1;
            } else {
                return n * pow(n, k-1);
            }
        }
        function pow5(n) {
            return pow(n, 5);
        }
    \end{verbatim}
    \tikz[remember picture, overlay] 
    \node[anchor=west,color=yellow,fill=yellow,draw,rectangle,text width=1.7cm, text height=.2cm, opacity=.5] 
            at (3.7,2) {};
\end{frame}

\begin{frame}[fragile]
    \begin{verbatim}
        function pow(n, k) {
            if (k <= 0) {
                return 1;
            } else {
                return n * pow(n, k-1);
            }
        }
        function pow5(n) {
            return n * pow(n, 4);
        }
    \end{verbatim}
    \tikz[remember picture, overlay] 
    \node[anchor=west,color=yellow,fill=yellow,draw,rectangle,text width=2.5cm, text height=.2cm, opacity=.5] 
    at (3.7,2) {};
\end{frame}

\begin{frame}[fragile]
    \begin{verbatim}
        function pow(n, k) {
            if (k <= 0) {
                return 1;
            } else {
                return n * pow(n, k-1);
            }
        }
        function pow5(n) {
            return n * n * pow(n, 3);
        }
    \end{verbatim}
    \tikz[remember picture, overlay] 
    \node[anchor=west,color=yellow,fill=yellow,draw,rectangle,text width=3.5cm, text height=.2cm, opacity=.5] 
    at (3.7,2) {};
\end{frame}

\begin{frame}[fragile]
    \begin{verbatim}
        function pow(n, k) {
            if (k <= 0) {
                return 1;
            } else {
                return n * pow(n, k-1);
            }
        }
        function pow5(n) {
            return n * n * n * n * n;
        }
    \end{verbatim}
\tikz[remember picture, overlay] 
\node[anchor=west,color=yellow,fill=yellow,draw,rectangle,text width=3.5cm, text height=.2cm, opacity=.5] 
at (3.7,2) {};
\end{frame}



\begin{frame}[fragile]
    \begin{verbatim}
        function pow(n, k) {
            if (k <= 0) {
                return 1;
            } else {
                return n * pow(n, k-1);
            }
        }
        let pow5 = alpha(pow, {k:5});
        // (n) => n * n * n * n * n;
    \end{verbatim}
    \tikz[remember picture, overlay] 
\node[anchor=west,color=yellow,fill=yellow,draw,rectangle,text width=3.5cm, text height=.2cm, opacity=.5] 
at (3.7,2) {};
\end{frame}

\begin{frame}{Partial Evaluator}
    
\begin{center}

    \begin{tikzpicture}
        \tikzstyle{every path}=[draw, ->]
        \tikzstyle{envel}=[shape=ellipse, draw]
        \tikzstyle{circ}=[draw, circle]
        \tikzstyle{box}=[draw, rectangle, text width=1cm, text height=.5cm, text centered, text depth=.3cm]
            \node [circ] (in1) at (2,3) {$k$};    
            \node [circ] (in2) at (2,1) {$u$};    
            \node [circ] (out) at (8,2) {$f(k,u)$};    
            \node [box] (box) at (5,2) {$f$};
            
            
            \path (in1) -- (box);    
            \path (in2) -- (box);    
            \path (box) -- (out);

            \pause

            \begin{scope}[shift={(in1))},x={(box)},y={($(in1)!1!90:(box)$)}]
                \draw[red] (.5,0) ellipse (.8 and .5);
            \end{scope}

            \pause

            \node[box](proj) at (5,-.5) {$f_k$};

            \draw[
                line join=round,
                decorate, decoration={
                zigzag,
                segment length=4,
                amplitude=1,post=lineto,
                post length=2pt}] (5,.9) -- (proj) node [midway, label=right:{$\alpha$}] {} ;
            
    \end{tikzpicture}
    
\end{center}

\end{frame}

\begin{frame}{Partial Evaluator}

    A partial computation procedure may be a computer program $\alpha$
    called \textit{a projection machine}, \textit{partial computer} 
    or \textit{partial evaluator}.
    
    \begin{equation}
        \alpha(f,k) = f_k
    \end{equation}
    
\end{frame}


\begin{frame}{Basic Equation of Partial Evaluation}

    $\alpha$ is a partial evaluator; but $\alpha$ is itself a program.

    Thus, consider $\alpha_f$, the partial evaluation of $\alpha$ at $f$:
\begin{eqnarray}
            \alpha_f(k) &=& \alpha(f,k) \nonumber \\
            \alpha(f,k) &=& f_k         \nonumber \\
            \alpha_f(k) &=& f_k 
\end{eqnarray}

\end{frame}

\setbeamercovered{transparent} 

\begin{frame}{Examples}

    The paper presents:

    \begin{itemize}
        \item<1> Automatic theorem proving
        \item<1> Pattern matching
        \item<1> Syntax analyzer
        \item<1,2> Automatically generating a compiler
    \end{itemize}
    
\end{frame}

\setbeamercovered{} 

\begin{frame}{Interpreters and Compilers (\textit{reprise})}
    \begin{itemize}
        \item An interpreter is a \textit{program}
        \item This \emph{program} takes another \textit{program} and the data as input
        \item It evaluates the program on the input and returns the result

    \end{itemize}
    \[
        \I(\P,\D) = \R    
    \]
    \pause

    \begin{itemize}
        \item A compiler is a \textit{program}
        \item This \emph{program} takes a \textit{source program} 
                and returns an \textit{object program}
        \item The \textit{object program} processes the input and returns the result
    \end{itemize}
    \[
        \C(\P)(\D) = \R    
    \]

\end{frame}



\begin{frame}{Partial Evaluation of an Interpreter}


\begin{center}

    \begin{tikzpicture}
        \tikzstyle{every path}=[draw, ->]
        \tikzstyle{envel}=[shape=ellipse, draw]
        \tikzstyle{circ}=[draw, circle]
        \tikzstyle{box}=[draw, rectangle, text width=1cm, text height=.5cm, text centered, text depth=.3cm]
            \node [circ] (in1) at (2,3) {\P};    
            \node [circ] (in2) at (2,1) {\D};    
            \node [circ] (out) at (8,2) {\R};    
            \node [box] (box) at (5,2) {\I};
            
            
            \path (in1) -- (box);    
            \path (in2) -- (box);    
            \path (box) -- (out);

            \pause

            \begin{scope}[shift={(in1))},x={(box)},y={($(in1)!1!90:(box)$)}]
                \draw[red] (.5,0) ellipse (.8 and .5);
            \end{scope}

            \pause

            \node[box](proj) at (5,-.5) {$\I_\P$};

            \draw[
                line join=round,
                decorate, decoration={
                zigzag,
                segment length=4,
                amplitude=1,post=lineto,
                post length=2pt}] (5,.9) -- (proj) node [midway, label=right:{$\alpha$}] {} ;
            
    \end{tikzpicture}
    
\end{center}

\end{frame}


\begin{frame}{Partially Evaluated Interpreter}
    \begin{center}
    
        \begin{tikzpicture}
            \tikzstyle{every path}=[draw, ->]
            \tikzstyle{circ}=[draw, circle]
            \tikzstyle{box}=[draw, rectangle, text width=1cm, text height=.5cm, text centered, text depth=.3cm]
                \node [circ] (in) at (2,2) {\D};    
                \node [circ] (out) at (8,2) {\R};    
                \node [box] (box) at (5,2) {$\I_\P$}; 
                \path (in) -- (box);    
                \path (box) -- (out);    
        \end{tikzpicture}
        
    \end{center}

    \begin{itemize}
    \item That is, by feeding \D into $\I_\P$, you get \R;
    \item in other words, $\I_\P$ is \textit{an object program}.
    \end{itemize}
    
\end{frame}


\begin{frame}{First Equation of Partial Computation (First Projection)}

    
% An \textit{interpreter} $\mathcal{I}$ is a program to perform
% specified computations that analyze the meanings of a given program, 
% say $\mathcal{P}$, based upon given data, say $\mathcal{D}$. 

We recall the previous definitions of \textit{interpreter}
and \textit{compiler}.

\begin{eqnarray}
    \mathcal{I}(\mathcal{P}, \mathcal{D}) &=& \R \nonumber \\
    \C(\P)&=&\P' \nonumber \\
    \P' &=& \R \nonumber  \\
    \mathcal{C}(\mathcal{P})(\mathcal{D}) &=& \mathcal{I}(\mathcal{P},\mathcal{D}) \nonumber \\
    \mathcal{I}_{\mathcal{P}} &=&  \alpha(\mathcal{I},\mathcal{P}) \nonumber \\ 
    \mathcal{I}_{\mathcal{P}} &=&  \mathcal{C}(\mathcal{P})
\end{eqnarray}


\end{frame}

\begin{frame}{Partial Evaluation of an Interpreter}

    \begin{center}
    
        \begin{tikzpicture}
            \tikzstyle{every path}=[draw, ->]
            \tikzstyle{envel}=[shape=ellipse, draw]
            \tikzstyle{circ}=[draw, circle]
            \tikzstyle{box}=[draw, rectangle, text width=1cm, text height=.5cm, text centered, text depth=.3cm]
                \node [circ] (in1) at (2,3) {\I};    
                \node [circ] (in2) at (2,1) {\P};    
                \node [circ] (out) at (8,2) {$\I_\P$};    
                \node [box] (box) at (5,2) {$\alpha$};
                
                
                \path (in1) -- (box);    
                \path (in2) -- (box);    
                \path (box) -- (out);
    
                \pause
    
                \begin{scope}[shift={(in1))},x={(box)},y={($(in1)!1!90:(box)$)}]
                    \draw[red] (.5,0) ellipse (.8 and .5);
                \end{scope}
    
                \pause
    
                \node[box](proj) at (5,-.5) {$\alpha_\I$};
    
                \draw[
                    line join=round,
                    decorate, decoration={
                    zigzag,
                    segment length=4,
                    amplitude=1,post=lineto,
                    post length=2pt}] (5,.9) -- (proj) node [midway, label=right:{$\alpha$}] {} ;
                
        \end{tikzpicture}
        
    \end{center}
    
    \end{frame}


\begin{frame}{Second Equation of Partial Computation (Second Projection)}

    

    \begin{center}
    
        \begin{tikzpicture}
            \tikzstyle{every path}=[draw, ->]
            \tikzstyle{circ}=[draw, circle]
            \tikzstyle{box}=[draw, rectangle, text width=1cm, text height=.5cm, text centered, text depth=.3cm]
                \node [circ] (in) at (2,2) {\P};    
                \node [circ] (out) at (8,2) {$\I_\P$};    
                \node [box] (box) at (5,2) {$\alpha_\I$}; 
                \path (in) -- (box);    
                \path (box) -- (out);    
        \end{tikzpicture}
        
    \end{center}


    \begin{equation}
    \alpha_\mathcal{I}(\mathcal{P}) =  \mathcal{I}_\mathcal{P}
    \end{equation}
    
    \begin{itemize}
        \item but $\I_\P$, evaluated on \D gives \R; then
        \item $\I_\P$ is an object program ($\P'$)
        \item $\alpha_\I$ transforms a source program $\P$ to $\I_\P$
        \item then $\alpha_\I$ is \textit{a compiler}
    \end{itemize}
    
\end{frame}


\begin{frame}
    \tikz[overlay]
    \node at (5,0) {\includegraphics[width=18cm]{imgs/inception.jpg}};
\end{frame}



\begin{frame}{Partial Evaluation of a Partial Evaluator}


    \begin{center}
    
        \begin{tikzpicture}
            \tikzstyle{every path}=[draw, ->]
            \tikzstyle{envel}=[shape=ellipse, draw]
            \tikzstyle{circ}=[draw, circle]
            \tikzstyle{box}=[draw, rectangle, text width=1cm, text height=.5cm, text centered, text depth=.3cm]
                \node [circ] (in1) at (2,3) {$\alpha$};    
                \node [circ] (in2) at (2,1) {\I};    
                \node [circ] (out) at (8,2) {$\alpha_\I$};    
                \node [box] (box) at (5,2) {$\alpha$};
                
                
                \path (in1) -- (box);    
                \path (in2) -- (box);    
                \path (box) -- (out);
    
                \pause
    
                \begin{scope}[shift={(in1))},x={(box)},y={($(in1)!1!90:(box)$)}]
                    \draw[red] (.5,0) ellipse (.8 and .5);
                \end{scope}
    
                \pause
    
                \node[box](proj) at (5,-.5) {$\alpha_\alpha$};
    
                \draw[
                    line join=round,
                    decorate, decoration={
                    zigzag,
                    segment length=4,
                    amplitude=1,post=lineto,
                    post length=2pt}] (5,.9) -- (proj) node [midway, label=right:{$\alpha$}] {} ;
                
        \end{tikzpicture}
        
    \end{center}
    
    \end{frame}


\begin{frame}{Third Equation of Partial Computation (Third Projection)}

    \begin{center}
    
        \begin{tikzpicture}
            \tikzstyle{every path}=[draw, ->]
            \tikzstyle{circ}=[draw, circle]
            \tikzstyle{box}=[draw, rectangle, text width=1cm, text height=.5cm, text centered, text depth=.3cm]
                \node [circ] (in) at (2,2) {\I};    
                \node [circ] (out) at (8,2) {$\alpha_\I$};    
                \node [box] (box) at (5,2) {$\alpha_\alpha$}; 
                \path (in) -- (box);    
                \path (box) -- (out);    
        \end{tikzpicture}
        
    \end{center}

    \begin{equation}
    \alpha_\alpha(\mathcal{I}) =  \alpha_\mathcal{I}
    \end{equation}
    
    \begin{itemize}
     \item $\alpha_\alpha$ is a program, that given \I, returns $\alpha_\I$
     \item $\alpha_\I$ transforms a source program to an object program
     \item $\alpha_\I$ is a compiler
     \item $\alpha_\alpha$ is a \textit{compiler-compiler} (a \textit{compiler generator})
            which generates a compiler $\alpha_\I$ from an interpreter $\I$
    \end{itemize}
\end{frame}

\begin{frame}
    \centering
    \tikz
    \node at (0,0) {\includegraphics[width=9cm]{imgs/escher.jpg}};
\end{frame}


\begin{frame}{Partial Evaluation of a Partially-Evaluated Evaluator}

    \begin{itemize}
    \item Let us call \I-language a language implemented by interpreter \I,  
    
    \[
        \alpha_\alpha(\mathcal{I}) =  \alpha_\mathcal{I}
    \]
    

    \item $\alpha_\I$ is then a \I-language compiler,  
    \item let us now substitute $\alpha$ for $\I$ in $\alpha_\alpha(\mathcal{I}) = \alpha_\mathcal{I}$,
    \item which means considering $\alpha$ an interpreter for the $\alpha$-language.
    
    \[
        \alpha_\alpha(\alpha)=\alpha_\alpha    
    \]

    \item $\alpha_\alpha$ is an $\alpha$-language compiler.


    \end{itemize}


\end{frame}

\begin{frame}{Fourth Equation of Partial Computation}

    \[
        \alpha_\alpha(\alpha)=\alpha_\alpha    
    \]

    \begin{center}
    
        \begin{tikzpicture}
            \tikzstyle{every path}=[draw, ->]
            \tikzstyle{circ}=[draw, circle]
            \tikzstyle{box}=[draw, rectangle, text width=1cm, text height=.5cm, text centered, text depth=.3cm]
                \node [circ] (in) at (2,2) {$\alpha$};    
                \node [circ] (out) at (8,2) {$\alpha_\alpha$};    
                \node [box] (box) at (5,2) {$\alpha_\alpha$}; 
                \path (in) -- (box);    
                \path (box) -- (out);    
        \end{tikzpicture}
        
    \end{center}
    


    \begin{itemize}
    \item $\alpha_\alpha$ is an $\alpha$-language compiler.
    \item $\alpha_\alpha(f)$ is an object program of $f$; thus:
    \item What is the $\alpha$-language?
    \begin{equation}
        \alpha_\alpha(f)(k) =  f_k
    \end{equation}
    \end{itemize}


\end{frame}

\begin{frame}

    \begin{itemize}
        \item What is the $\alpha$-language?
        \[
            \alpha_\alpha(f)(k) =  f_k
        \]

    \item In other words, by finding $\alpha_\alpha$ we can generate
    the partial computation of $f$ at $k$, $f_k$
    
    \item That is, $\alpha_\alpha$ is a \emph{partial evaluation compiler}.

    \item However, \emph{the author notes}, at the time of writing, 
    there is no way to produce $\alpha_\alpha$ from $\alpha(\alpha, \alpha)$
    for practical $\alpha$'s.
    \end{itemize}

\end{frame}




\begin{frame}[c]
    \centering \Large \bf \color{Blue} Theory of Partial Computation \\ and \\ Technical Problems 
    \end{frame}

\begin{frame}{Theory of Partial Computation}
    \begin{itemize}
        \item 
            in the 1930's Turing, Church, Kleene proposed several
            computational models and clarified the mathematical meanings of mechanical
            procedure.
        \item a \emph{computation model} is a sort of programming language
        \item \emph{e.g.} Turing machines, lambda expressions, and  partial recursive functions.
        \pause
        \item 
            research on \emph{computability}, \emph{i.e.,} \emph{computational power} 
            of the models, not complexity or efficiency
        % \item as far as computability was concerned, partial computation is the same as 
        %     ordinary computation: it did not attract research attention
    \end{itemize}
\end{frame}

\begin{frame}{$s^m_n$ theorem}
    Appears in Kleene $s^m_n$ theorem (parameterization theorem, iteration theorem). 
    % for any $m, n > 0$, there exists a primitive recursive function 
    % $ s_{n}^{m}$ of $m + 1$ arguments that behaves as follows: 
    % for every Gödel number $p$ of a partial computable function with $m + n$ 
    % arguments, and all values of $x_1,\dots,x_m$: 
    
    % \[
    %     \varphi_{s^m_n(p,x_1, \dots, x_m)} 
    %         \simeq         
    %             \lambda y_1, \dots, y_n \cdot \varphi_p (x_1, \dots, x_m, y_1, \dots, y_n) 
    % \]


    $\varphi^{(k)}_x$ recursive function of $k$
 variables with \emph{G\"odel number} $x$; 
 then for every $m\geq 1$ and $n\geq 1$ there exists
 a \emph{primitive recursive function} $s$ such that for all 
 $x, y_1, \dots, y_m$
 
 
    
 \[
    \lambda z_1, \dots, z_n \: \varphi_x^{(m+n)} (y_1, \dots, y_m, z_1, \dots, z_n) = \varphi^{(n)}_{s(x,y_1, \dots, y_m)}
\]


The third equation of partial computation ($\alpha_\alpha$)
is also used in the proof of Kleene's recursion theorem



\end{frame}

\begin{frame}
    \begin{itemize}
        \item Turing machines and partial recursive functions were formulated to describe total computation
        \item Chruch's lambda expression was based upon partial computation
        \item \emph{lambda conversion} is partial computation: $f(5,u)$ with $u$ undefined, yields $f_5(u)$
    \end{itemize}
\end{frame}


\begin{frame}
    Implementation of a projection machine and its application to real world
    problems started in the 1960's after the programming language LISP
    began to be widely used
   
\end{frame}


\begin{frame}{Conditions for a Projection Machines}
    \begin{enumerate}
        \item Correctness: 
            Program $\alpha$ must satisfy $\alpha(f,k)(u)=f(k,u)$
        \item Efficiency Improvement: 
            Program $\alpha$ should perform as much computation as possible
            for the given data $k$
        \item Termination:
            Program $\alpha$ should terminate on partial computation of as 
            many programs as possible. Termination at $\alpha(\alpha,\alpha)$ 
            is most desirable
    \end{enumerate}

However, author notes, (2) is not \textit{mathematically clear}

\end{frame}

\begin{frame}{Recursive Program Schema}
    \begin{enumerate}
        \item Condition
        \item Expression
        \item Function Definition
    \end{enumerate}

\end{frame}

\begin{frame}{Computation Rule for Recursive Program Schema}


    \begin{enumerate} 
        \item Rewriting
        \item Simplification
    \end{enumerate}

    Partial Computation of $f$ at $k$:

    \begin{enumerate}
        \item Rewriting (when semi-bound)
        \item Simplification
        \item Tabulation
    \end{enumerate}

    The discriminating character for p.c. are the semi-bound call and tabulation.

\end{frame}

\begin{frame}{Rewriting and Simplification}
    \textbf{Rewriting} is
    similar to macro expansion and \textit{procedure integration} 
    in the optimization technique of a compiler. Often combined with
    \textbf{simplification.}

    \centering
    \tikz 
    \node at (current page.center) {\includegraphics[width=.7\textwidth]{imgs/fig6.png}};

    
\end{frame}

\begin{frame}
    \centering 
    \tikz 
    \node at (current page.center) {\includegraphics[width=.7\textwidth]{imgs/tabulation.png}};
\end{frame}


\begin{frame}[c]
\centering \Large \bf \color{Blue} GraalVM 
\end{frame}

\begin{frame}
    \centering 
    \tikz 
    \node at (current page.center) {\includegraphics[width=\textwidth]{imgs/truffle.png}};

\end{frame}


\begin{frame}

    We implement the language semantics only once in a
simple form: as a \alert<2>{language interpreter} written in a 
managed high-level host language. Optimized compiled code is
\alert<2>{derived from the interpreter using partial evaluation}. This
approach and its obvious benefits were described in 1971
by Y. Futamura, and is known as the \alert<2>{\textit{first Futamura
projection}}. To the best of our knowledge no prior high-
performance language implementation used this approach.

\end{frame}
     
\begin{frame}

We believe that a simple partial evaluation of a dynamic
language interpreter cannot lead to high-performance compiled code: 
if the \alert<2>{complete semantics} for a language operation are included 
during partial evaluation, the \alert<2>{size of the
compiled code explodes}; if language operations are not included 
during partial evaluation and \alert<2>{remain runtime calls},
\alert<2>{performance is mediocre}. To overcome these inherent problems, 
we write the interpreter in a style that anticipates and
embraces partial evaluation. The \alert<2>{interpreter specializes the
executed instructions}, e.g., collects type information and
profiling information. The compiler \alert<2>{speculates} that the interpreter 
state is stable and creates highly optimized 
and compact machine code. If a speculation turns out to be wrong,
i.e., was too optimistic, execution transfers back to the interpreter. 
The interpreter updates the information, so that the
next partial evaluation is less speculative.
\end{frame}

\begin{frame}
    \tikz 
    \node at (current page.center) {\includegraphics[width=\textwidth]{imgs/onevm.png}};
\end{frame}




\begin{frame}[c]
    \centering \Large \bf \color{Blue} Q\&A 
    \end{frame}

\end{document}
    